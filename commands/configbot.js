const { ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionsBitField, EmbedBuilder } = require('discord.js');
const { sendRandomMessage } = require('../utils/randomMessage'); // Importe a fun√ß√£o
const { isTimeAllowed } = require('../utils/timeUtils');

let interactionChannelId = null;
let logsChannelId = null;
let mentionFrequency = 5; // Frequ√™ncia padr√£o
let likeEmojis = []; // Lista de emojis para curtidas

function getMainMenuContent() {
    const description = `\`\`\`üéõÔ∏è Configura√ß√£o do Pixelzinho\`\`\`\n` +
        `O Pixelzinho √© um bot personaliz√°vel que permite configurar diversos par√¢metros de intera√ß√£o, desde men√ß√µes at√© respostas autom√°ticas, tudo para garantir uma experi√™ncia din√¢mica e personalizada para o seu servidor.\n` +
        `\n` +
        `‚ùó **Para que o bot funcione corretamente, o primeiro menu que voc√™ deve configurar √© o de "Canais"**. Aqui voc√™ definir√° os canais nos quais o bot poder√° interagir e enviar notifica√ß√µes, garantindo que ele esteja ativo nos locais corretos do servidor.\n` +
        `\n` +
        `## **O que deseja configurar?**\n` +
        `\n` +
        `Escolha uma das op√ß√µes abaixo para ajustar os par√¢metros do bot de acordo com suas prefer√™ncias.\n` +
        `\n` +
        `ùÑÉùÑÉùÑÇùÑÇùÑÄùÑÅùÑÉùÑÇùÑÇùÑÉ Fl√°via Machado ¬Æ *Pliss Studio 2024*`;

    const embed = new EmbedBuilder()
        .setColor('#9B59B6') // Cor roxa
        .setDescription(description);

    const row = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('config_canais')
                .setLabel('Canais')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setCustomId('config_mencoes')
                .setLabel('Men√ß√µes')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setCustomId('config_curtidas')
                .setLabel('Curtidas')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setCustomId('config_sair')
                .setLabel('Sair')
                .setStyle(ButtonStyle.Danger)
        );

    return { embeds: [embed], components: [row] };
}

function handleConfigCommand(interaction) {
    const member = interaction.member || interaction.guild.members.cache.get(interaction.user.id);

    if (!member.permissions.has(PermissionsBitField.Flags.Administrator) && interaction.user.id !== interaction.guild.ownerId) {
        interaction.reply({ content: 'üìõ **Voc√™ n√£o tem permiss√£o para configurar o bot.**', ephemeral: true });
        return;
    }

    const { embeds, components } = getMainMenuContent();

    if (interaction.replied || interaction.deferred) {
        interaction.followUp({ embeds, components });
    } else if (interaction.isButton && interaction.isButton()) {
        interaction.update({ embeds, components });
    } else {
        interaction.reply({ embeds, components });
    }
}

async function handleButtonInteraction(interaction, client) {
    const member = interaction.member || interaction.guild.members.cache.get(interaction.user.id);

    if (!member.permissions.has(PermissionsBitField.Flags.Administrator) && interaction.user.id !== interaction.guild.ownerId) {
        await interaction.reply({ content: 'Voc√™ n√£o tem permiss√£o para configurar o bot.', ephemeral: true });
        return;
    }

    if (interaction.customId === 'config_canais') {
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('canais_logs')
                    .setLabel('Logs')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('canais_interacoes')
                    .setLabel('Intera√ß√µes')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('canais_voltar')
                    .setLabel('Voltar')
                    .setStyle(ButtonStyle.Secondary)
            );

        const description = `\`\`\`üì¢ Configura√ß√£o de Canais\`\`\`\n` +
            `Defina os canais que o bot utilizar√° para enviar mensagens e registrar atividades.\n` +
            `\n` +
            `‚§∑ **Logs:** Escolha o canal para receber registros sobre o funcionamento do bot.\n` +
            `‚§∑ **Intera√ß√µes:** Escolha o canal por onde o bot enviar√° mensagens de intera√ß√£o.\n` +
            `\n` +
            `**Como pegar o ID do canal:** Clique com o bot√£o direito no canal desejado e selecione "Copiar ID". Certifique-se de que o modo de desenvolvedor est√° ativado nas configura√ß√µes do Discord.`;

        const embed = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription(description);

        await interaction.update({
            embeds: [embed],
            components: [row]
        });

    } else if (interaction.customId === 'canais_interacoes') {
        const embed = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription('Envie o ID do Canal para que o bot envie mensagens de Intera√ß√£o por ele');

        await interaction.update({
            embeds: [embed],
            components: []
        });
        const filter = m => m.author.id === interaction.user.id;
        const collector = interaction.channel.createMessageCollector({ filter, max: 1, time: 60000 });

        collector.on('collect', async m => {
            interactionChannelId = m.content.trim();
            console.log(`ID do Canal de Intera√ß√µes: ${interactionChannelId}`);

            const embedConfirmation = new EmbedBuilder()
                .setColor('#9B59B6')
                .setDescription(`ID do Canal de Intera√ß√µes salvo: ${interactionChannelId}\n ‚úî Configura√ß√£o conclu√≠da. Retornando ao menu de configura√ß√£o dos canais...`);

            await interaction.followUp({
                embeds: [embedConfirmation],
                components: []
            });
            sendLogMessage(client, `üí¨ **ID do Canal de Intera√ß√µes:** ${interactionChannelId}`);
            await showChannelConfigMenu(interaction);
        });

        collector.on('end', collected => {
            if (collected.size === 0) {
                interaction.followUp('Tempo esgotado. Por favor, tente novamente.');
            }
        });
    } else if (interaction.customId === 'canais_logs') {
        const embed = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription('Envie o ID do Canal para que o bot envie registros de logs por ele');

        await interaction.update({
            embeds: [embed],
            components: []
        });
        const filter = m => m.author.id === interaction.user.id;
        const collector = interaction.channel.createMessageCollector({ filter, max: 1, time: 60000 });

        collector.on('collect', async m => {
            logsChannelId = m.content.trim();
            console.log(`ID do Canal de Logs: ${logsChannelId}`);

            const embedConfirmation = new EmbedBuilder()
                .setColor('#9B59B6')
                .setDescription(`ID do Canal de Logs salvo: ${logsChannelId}\n ‚úî Configura√ß√£o conclu√≠da. Retornando ao menu de configura√ß√£o dos canais...`);

            await interaction.followUp({
                embeds: [embedConfirmation],
                components: []
            });
            sendLogMessage(client, `üõ†Ô∏è **ID do Canal de Logs:** ${logsChannelId}`);
            await showChannelConfigMenu(interaction);
        });

        collector.on('end', collected => {
            if (collected.size === 0) {
                interaction.followUp('Tempo esgotado. Por favor, tente novamente.');
            }
        });
    } else if (interaction.customId === 'canais_voltar' || interaction.customId === 'mencoes_voltar' || interaction.customId === 'curtidas_voltar') {
        const { embeds: mainEmbeds, components: mainComponents } = getMainMenuContent();
        await interaction.update({ embeds: mainEmbeds, components: mainComponents });

    } else if (interaction.customId === 'config_mencoes') {
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mencoes_baixa')
                    .setLabel('Baixa (3x)')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mencoes_moderada')
                    .setLabel('Moderada (5x)')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mencoes_alta')
                    .setLabel('Alta (10x)')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mencoes_louca')
                    .setLabel('Louca! (20x)')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mencoes_voltar')
                    .setLabel('Voltar')
                    .setStyle(ButtonStyle.Secondary)
            );

        const description = `\`\`\`üí¨ Configura√ß√£o de Men√ß√µes\`\`\`\n` +
            `Defina a frequ√™ncia com que o bot enviar√° mensagens de men√ß√£o ao longo do dia.\n` +
            `\n` +
            `Escolha uma das op√ß√µes abaixo para ajustar a frequ√™ncia conforme sua prefer√™ncia:\n` +
            `\n` +
            `‚§∑ **Baixa (3x):** O bot enviar√° 3 men√ß√µes por dia.\n` +
            `‚§∑ **Moderada (5x):** O bot enviar√° 5 men√ß√µes por dia.\n` +
            `‚§∑ **Alta (10x):** O bot enviar√° 10 men√ß√µes por dia.\n` +
            `‚§∑ **Louca! (20x):** O bot enviar√° 20 men√ß√µes por dia.\n` +
            `\n` +
            `**Dica:** Escolha a frequ√™ncia que melhor se adapta ao seu servidor.`;

        const embed = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription(description);

        await interaction.update({
            embeds: [embed],
            components: [row]
        });

    } else if (interaction.customId.startsWith('mencoes_')) {
        let frequency;
        switch (interaction.customId) {
            case 'mencoes_baixa':
                frequency = 3;
                break;
            case 'mencoes_moderada':
                frequency = 5;
                break;
            case 'mencoes_alta':
                frequency = 10;
                break;
            case 'mencoes_louca':
                frequency = 20;
                break;
        }
        setMentionFrequency(frequency);

        const embedConfirmation = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription(`‚úî Frequ√™ncia de men√ß√µes definida para ${getFrequencyLabel(frequency)}.`);

        await interaction.update({
            embeds: [embedConfirmation],
            components: []
        });
        const scheduledTimes = scheduleMentions(client);
        sendLogMessage(client, `üì£ **Frequ√™ncia de Men√ß√µes:** ${getFrequencyLabel(frequency)}\n> *Hor√°rios: ${scheduledTimes.join(', ')}*`);
        handleConfigCommand(interaction);

    } else if (interaction.customId === 'config_curtidas') {
        const description = `\`\`\`üòÉ Configura√ß√£o de Curtidas\`\`\`\n` +
            `Personalize os emojis que o bot usar√° para reagir √†s mensagens.\n` +
            `\n` +
            `**Instru√ß√µes:** Clique em **'Definir Emojis'** para escolher at√© 5 emojis que v√£o ser usados nas rea√ß√µes de curtidas.`;

        const embed = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription(description);

        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('curtidas_enviar')
                    .setLabel('Definir Emojis')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('curtidas_voltar')
                    .setLabel('Voltar')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.update({
            embeds: [embed],
            components: [row]
        });

    } else if (interaction.customId === 'curtidas_enviar') {
        const embed = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription('Por favor, envie at√© 5 emojis para serem usados nas rea√ß√µes de curtidas.');

        await interaction.update({
            embeds: [embed],
            components: []
        });

        const filter = m => m.author.id === interaction.user.id;
        const collector = interaction.channel.createMessageCollector({ filter, max: 1, time: 60000 });

        collector.on('collect', async m => {
            likeEmojis = m.content.trim().split(/\s+/).slice(0, 5);
            console.log(`Emojis de Curtidas: ${likeEmojis.join(' ')}`);

            const embedConfirmation = new EmbedBuilder()
                .setColor('#9B59B6')
                .setDescription(`Emojis de Curtidas salvos: ${likeEmojis.join(' ')}\n ‚úî Configura√ß√£o conclu√≠da.`);

            await interaction.followUp({
                embeds: [embedConfirmation],
                components: []
            });
            sendLogMessage(client, `üòÉ **Emojis de Curtidas:** ${likeEmojis.join(' ')}`);
            handleConfigCommand(interaction);
        });

        collector.on('end', collected => {
            if (collected.size === 0) {
                interaction.followUp('Tempo esgotado. Por favor, tente novamente.');
            }
        });

    } else if (interaction.customId === 'config_sair') {
        const embed = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription('Tchau! üëã');

        await interaction.update({
            embeds: [embed],
            components: []
        });
    }
}

async function showChannelConfigMenu(interaction) {
    const row = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('canais_interacoes')
                .setLabel('Intera√ß√µes')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setCustomId('canais_logs')
                .setLabel('Logs')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setCustomId('canais_voltar')
                .setLabel('Voltar')
                .setStyle(ButtonStyle.Secondary)
        );

    const embed = new EmbedBuilder()
        .setColor('#9B59B6')
        .setDescription('Defina os canais de intera√ß√£o e de registro de atividades (logs)');

    await interaction.followUp({
        embeds: [embed],
        components: [row]
    });
}

function sendLogMessage(client, logMessage) {
    const guild = client.guilds.cache.first();
    const logsChannelId = getLogsChannelId();
    const logChannel = guild.channels.cache.get(logsChannelId);
    if (logChannel) {
        const embed = new EmbedBuilder()
            .setColor('#9B59B6')
            .setDescription(logMessage)
            .setTimestamp();

        logChannel.send({ embeds: [embed] }).catch(console.error);
    } else {
        console.log(`Canal de logs n√£o configurado ou n√£o encontrado. ID atual: ${logsChannelId}`);
    }
}

function setMentionFrequency(frequency) {
    mentionFrequency = frequency;
    console.log(`Frequ√™ncia de men√ß√µes definida para ${frequency}x por dia.`);
    // Reagendar men√ß√µes com a nova frequ√™ncia
}

function getMentionFrequency() {
    return mentionFrequency;
}

function getLikeEmojis() {
    return likeEmojis;
}

function getInteractionChannelId() {
    return interactionChannelId;
}

function getLogsChannelId() {
    return logsChannelId;
}

let scheduledMentionTimeouts = []; // Para rastrear os timeouts agendados

function scheduleMentions(client) {
    // Limpa qualquer timeout existente
    scheduledMentionTimeouts.forEach(timeout => clearTimeout(timeout));
    scheduledMentionTimeouts = [];

    const scheduledTimes = [];
    const frequency = getMentionFrequency(); // Obter a frequ√™ncia atual

    // Definir o intervalo permitido
    const startHour = 7;
    const startMinute = 0;
    const endHour = 23;
    const endMinute = 50;

    // Calcular o hor√°rio de in√≠cio e t√©rmino
    let startTime = new Date();
    startTime.setHours(startHour, startMinute, 0, 0);
    let endTime = new Date();
    endTime.setHours(endHour, endMinute, 0, 0);

    // Se o hor√°rio atual for ap√≥s o hor√°rio de t√©rmino, agendar para o pr√≥ximo dia
    const now = new Date();
    if (now > endTime) {
        startTime.setDate(startTime.getDate() + 1);
        endTime.setDate(endTime.getDate() + 1);
    } else if (now < startTime) {
        // Se o hor√°rio atual for antes do hor√°rio de in√≠cio, ajustar o startTime para hoje
        startTime.setDate(startTime.getDate());
        endTime.setDate(endTime.getDate());
    }

    // Calcular o total de minutos no intervalo permitido
    const totalMinutes = (endTime - startTime) / (60 * 1000);

    // Calcular o intervalo entre as mensagens
    const intervalMinutes = totalMinutes / (frequency - 1); // Subtrai 1 para espa√ßar corretamente

    for (let i = 0; i < frequency; i++) {
        // Calcular o hor√°rio para cada mensagem
        const mentionTime = new Date(startTime.getTime() + intervalMinutes * i * 60 * 1000);
        scheduledTimes.push(mentionTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));

        const delay = mentionTime.getTime() - now.getTime();

        if (delay <= 0) {
            continue; // Ignora hor√°rios no passado
        }

        const timeout = setTimeout(() => {
            const currentTime = new Date();
            if (!isTimeAllowed(currentTime)) {
                console.log("Fora do hor√°rio permitido. Mensagem n√£o enviada.");
                return;
            }

            const guild = client.guilds.cache.first();
            const interactionChannelId = getInteractionChannelId();
            const channel = guild.channels.cache.get(interactionChannelId);

            if (channel) {
                sendRandomMessage(channel);
                console.log("Mensagem aleat√≥ria enviada.");
                sendLogMessage(client, "> ‚û§ **Mensagem aleat√≥ria enviada.**");

                // Verificar se todas as mensagens foram enviadas
                scheduledMentionTimeouts.shift(); // Remove o timeout executado
                if (scheduledMentionTimeouts.length === 0) {
                    // Agendar o pr√≥ximo lote de mensagens para o pr√≥ximo dia
                    scheduleNextDayMentions(client);
                }
            } else {
                console.log(`Canal de intera√ß√µes n√£o configurado ou n√£o encontrado. ID atual: ${interactionChannelId}`);
                sendLogMessage(client, `Canal de intera√ß√µes n√£o configurado ou n√£o encontrado. ID atual: ${interactionChannelId}`);
            }
        }, delay);

        scheduledMentionTimeouts.push(timeout);
    }


    return scheduledTimes;
}

function getFrequencyLabel(frequency) {
    switch(frequency) {
        case 3:
            return 'Baixa (3x por dia)';
        case 5:
            return 'Moderada (5x por dia)';
        case 10:
            return 'Alta (10x por dia)';
        case 20:
            return 'Louca! (20x por dia)';
        default:
            return `${frequency}x por dia`;
    }
}

function scheduleNextDayMentions(client) {
    // Calcula o tempo at√© a meia-noite
    const now = new Date();
    const nextMidnight = new Date(now);
    nextMidnight.setDate(now.getDate() + 1);
    nextMidnight.setHours(0, 0, 0, 0);

    const timeUntilMidnight = nextMidnight - now;

    setTimeout(() => {
        scheduleMentions(client);
    }, timeUntilMidnight);
}   

function getRandomTime(startHour, endHour, endMinute) {
    const date = new Date();
    const start = new Date(date.getFullYear(), date.getMonth(), date.getDate(), startHour, 0, 0);
    const end = new Date(date.getFullYear(), date.getMonth(), date.getDate(), endHour, endMinute, 0);

    const randomTime = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
    return randomTime;
}

module.exports = {
    handleConfigCommand,
    handleButtonInteraction,
    getInteractionChannelId,
    getLogsChannelId,
    setMentionFrequency,
    sendLogMessage,
    showChannelConfigMenu,
    scheduleMentions,
    getMentionFrequency,
    getLikeEmojis
};